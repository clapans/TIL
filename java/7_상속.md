## 1-3 클래스간의 관계 결정하기



### 상속관계 vs 포함관계



의미론적으로는

```
원(Circle)은 점(Point)이다.
원(Circle)은 점(Point)를 가지고 있다.
```

의 차이를 가지고 있다고 볼 수 있다.(클래스 명을 적절하게 짰다고 가정한다면)

~을 가지고 있다. 라는 의미는 '상속관계와 비교했을 때 포함관계는 인스턴스 여러 개를 포함할 수 있다.' 라고 해석할 수 있다.



코드의 진행을 생각해봤을 때의 차이를 본다면

포함관계는 인스턴스 변수로 다른 인스턴스 객체를 받기에 상속관계랑 비교했을 때 포함관계의 객체를 생성 할 때는 복수 개의 객체가 생성된다.



### 오버라이딩



```java
...
    
class Shape{
    String color = 'black';
    void draw(){
        System.out.printf("[color=%s]%n", color);
    }
}

...
    
class Circle extend Shape{
    ...
    void draw() {
        System.out.printf("[center=(%d, %d), r=%d, color=%s]%n", center.x, center.y, r, color);
    }
}

//결과 : [center=(150,150), r=50, color=black]
```



Shape 클래스를 상속받은 Circle 클래스에는 두 클래스 모두 draw 인스턴스 메소드를 가지고 있다.

두 draw 메소드 모두 매개변수를 받지 않아 이는 오버라이딩(재정의) 된다고 할 수 있다.

Shape 클래스에서 정의되었던 메소드 draw()가 Circle 클래스에서 오버라이딩 되고

따라서 Circle 인스턴스에서 draw 메소드를 사용한다면 위의 주석과 같은 결과가  나온다.

그럼, Shape 인스턴스에서 draw 메소드는 어떨까?



### toString



모든 클래스의 조상 클래스의 Object의 메소드로 정의된 toString()

참조변수를 출력하면 자동으로 호출돼 출력된다.(Python의 str 매직메소드와 유사)

오버라이딩을 통해 사용자가 출력 형식을 지정할 수 있다.

equals 와 같은 메소드가 이와 같이 재정의를 통해 사용 가능!



예시는 아래와 같다.

```java
boolean equals(Object other){
    return this.x == other.x;
  }
```





## 1-4 단일 상속



C++ 와 달리 자바에서는 다중 상속을 허용하지 않는다.

상속받은 복수의 클래스에서 같은 메소드가 존재할 시 어느 조상클래스의 메소드를 상속받을 것인가는 알 수 없기 때문



대신 하나의 클래스를 상속받고 다른 클래스와의 관계는 포함관계로 연결하여 이러한 문제는 다소 해결할 수 있다.



## 1-5 Object 클래스 - 모든 클래스의 조상



모든 클래스는 상속받는 클래스가 따로 존재하지 않는다면

```java
class Tv{
    ...
}
```



위에와 같다면 자동적으로 자바 내부적으로 Object 클래스를 상속받고 있는 것이다.



```java
class Tv extends Object{
    ...
}
```



이렇게 함으로써 모든 클래스의 조상클래스로 Object 클래스가 존재하도록 한다.



**  다중 상속을 받을 순 없지만 어떤 한 조상 클래스로부터 상속을 받는 다면 그 조상 클래스 역시 조상을 계속 찾아가다보면 결국엔 Object 클래스가 나오기 때문!